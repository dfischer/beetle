%
% The definition of Beetle
%
% Reuben Thomas
%
% Started 1/6-29/10/93; revised 1/8/94-4/5/95
% corrected 21/2/96
% use "machine" instead of "processor" 19/2/11
%


\section{Introduction}

Beetle is a simple virtual machine designed to enable the easy implementation
of ANS Forth compilers, such as pForth~\cite{beetledis}, on different systems.
It has twelve registers, two stacks, and an instruction set, called bForth, of
ninety-two instructions. The instruction set is based on the Core Word Set of
ANS Forth~\cite{ANSIforth}. This paper gives a full description of Beetle, but
certain implementation-dependent features, such as the size of the stacks, are
purposely left unspecified, and the exact method of implementation is left to
the implementor in many particulars.

Beetle is self-contained, and performs I/O via the {\tt LIB} instruction, which
provides access to a standard library which mimics ANS Forth I/O words. The
operating system and machine code routines on the host computer may be accessed
using the {\tt OS} and {\tt LINK} instructions. Beetle supports the saving and
loading of simple object modules.

Beetle may exist either as a stand-alone system, or embedded in other programs.
A small interface is provided for other programs wishing to control Beetle.

Since Beetle is heavily oriented towards supporting Forth compilers, it is
useful to understand how Forth compilers operate in order to understand Beetle
and to use it properly. An excellent introduction to Forth and Forth compilers
is \cite{starting4th}. An overview of the language and its compilers is also
provided in \cite{ANSIforth}. For an implementation of Beetle, see~\cite{beetledis}.


\section{Architecture}

Beetle's address unit is the byte, which is eight bits wide. Characters are one
byte wide, and cells are four bytes wide. The cell is the size of the numbers
and addresses on which Beetle operates, and of the items placed on the stacks.
The cell size is fixed to ensure compatibility of object code between
implementations on different machines; the size of the address unit, character
and cell has been chosen with a view to making efficient implementation of
Beetle possible on the vast majority of current machine architectures.

Cells may have the bytes stored in big-endian or little-endian order. The
address of a cell is that of the byte in it with the lowest address.


\subsection{Registers}
\label{registers}

The registers, each with its function and pronunciation, are set out in table~\ref{regtable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|c|p{3.75in}|} \hline
\rule[-2mm]{0mm}{6mm}\bf Register & \bf Pronunciation & \bf Function \\
    \hline
{\tt EP} & ``e-p'' & The {\tt E}xecution {\tt P}ointer. Points to the next
    cell from which an instruction word may be loaded. \\ \hline
{\tt I} & ``i'' & The {\tt I}nstruction. Holds the opcode of an instruction
    to be executed. \\ \hline
{\tt A} & ``a'' & The instruction {\tt A}ccumulator. Holds the opcodes of
    instructions to be executed, and immediate operands. \\ \hline
{\tt M0} & ``m-zero'' & The address of Beetle's address space on the host
    system, which must be aligned on a four-byte boundary. \\ \hline
{\tt MEMORY} & ``memory'' & The size in bytes of Beetle's address space,
    which must be a multiple of four. \\ \hline
{\tt SP} & ``s-p'' & The data {\tt S}tack {\tt P}ointer. \\ \hline
{\tt RP} & ``r-p'' & The {\tt R}eturn stack {\tt P}ointer. \\ \hline
{\tt 'THROW} & ``tick-throw'' & The address placed in {\tt EP} by a {\tt THROW}
    instruction. \\ \hline
{\tt ENDISM} & ``endism'' & The endianness of Beetle: 0 = Little-endian,
    1 = Big-endian. \\ \hline
{\tt CHECKED} & ``checked'' & 0 = address checking off, 1 = address checking
    on. \\ \hline
{\tt 'BAD} & ``tick-bad'' & The contents of {\tt EP} when the last exception
    was raised. \\ \hline
{\tt -ADDRESS} & ``not-address'' & The last address which caused an address
    exception. \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{regtable}Beetle's registers}
\end{table}

{\tt EP}, {\tt A}, {\tt MEMORY}, {\tt SP}, {\tt RP}, {\tt 'THROW}, {\tt 'BAD}
and {\tt -ADDRESS} are cell-wide quantities; {\tt I}, {\tt ENDISM} and {\tt
CHECKED} are one byte wide, and {\tt M0}'s size depends on the implementation;
it would normally have the same width as addresses on the host computer. The
values of {\tt MEMORY}, {\tt 'BAD} and {\tt -ADDRESS} are available in Beetle's
address space; {\tt 'THROW} must be physically held there so that it can be
changed as well as read by programs. Their addresses relative to {\tt M0} are
shown in table~\ref{mappedtable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|c|} \hline
\rule[-2mm]{0mm}{6mm}\bf Register & \bf Address \\ \hline
{\tt 'THROW} & 0h \\
{\tt MEMORY} & 4h \\
{\tt 'BAD} & 8h \\
{\tt -ADDRESS} & Ch \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{mappedtable}Registers which appear in Beetle's address
    space}
\end{table}

To ease efficient implementation, Beetle's stack pointers may only be accessed
by bForth instructions (see section~\ref{registerinst}).


\subsection{Memory}

Beetle's memory is a contiguous sequence of bytes numbered from 0 to {\tt
MEMORY}~$-$~1.


\subsection{Stacks}

The data and return stacks are cell-aligned LIFO stacks of cells. The stack
pointers point to the top stack item on each stack. To {\bf push} an item on to
a stack means to store the item in the cell beyond the stack pointer and then
adjust the pointer to point to it; to {\bf pop} an item means to make the
pointer point to the second item on the stack. The stacks grow downwards in
memory as new items are added. Instructions that change the number of items on a
stack implicitly pop their arguments and push their results.

The data stack is used for passing values to instructions and routines and the
return stack for holding subroutine return addresses and the index and limit of
the Forth {\tt DO\dots LOOP} construct. The return stack may be used for other
operations subject to the restrictions placed on it by its normal usage: it must
be returned before an {\tt EXIT} instruction to the state it was in directly
after the corresponding {\tt CALL}, and before a {\tt (LOOP)}, {\tt (+LOOP)}, or
{\tt UNLOOP} to the state it was in before the corresponding {\tt (DO)}.

In what follows, for ``the stack'' read ``the data stack''; the return stack is
always mentioned explicitly.


\subsection{Operation}
\label{operation}

Before Beetle is started, {\tt M0}, {\tt MEMORY} and {\tt ENDISM} should be set
to implementation-dependent values; {\tt 'THROW} should be set to point to the
exception handler, and {\tt EP} to the bForth code that is to be executed. {\tt
CHECKED} should be set to 0 or 1 as desired. The other registers should be
initialised as shown in table~\ref{inittable}, except for {\tt I} and {\tt A},
which need not be initialised.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|c|} \hline
\rule[-2mm]{0mm}{6mm}\bf Register & \bf Initial value \\ \hline
{\tt SP} & {\tt MEMORY} $-$ 100h \\
{\tt RP} & {\tt MEMORY} \\
{\tt 'BAD} & {FFFFFFFFh} \\
{\tt -ADDRESS} & {FFFFFFFFh} \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{inittable}Registers with prescribed initial values}
\end{table}

{\tt MEMORY} should be copied to 4h; its value and those of {\tt ENDISM} and
{\tt CHECKED} must not change while Beetle is executing. Next, the action of
{\tt NEXT} should be performed (see section~\ref{miscinst}): {\tt A} is loaded
from the cell to which {\tt EP} points, and four is added to {\tt EP}.

Beetle is started by a call to the interface calls {\bf run()} or {\bf
single\_step()} (see section~\ref{calls}). In the former case, the execution
cycle is entered:

\begin{tabbing}
\hspace{0.5in}\=begin\=\+\+ \\*
copy the least-significant byte of {\tt A} to {\tt I} \\*
shift {\tt A} arithmetically 8 bits to the right \\*
execute the instruction in {\tt I} \- \\*
repeat
\end{tabbing}

In the latter case, the contents of the execution loop is executed once, and
control returns to the calling program.

The execution loop need not be implemented as a single loop; it  is designed to
be short enough that the contents of the loop can be appended  to the code
implementing each instruction.

Note that the calls {\bf run()} and {\bf single\_step()} do not perform the
initialisation specified above; that must be performed before calling them.


\subsection{Termination}

When Beetle encounters a {\tt HALT} instruction (see section~\ref{exceptinst}),
it returns the top data stack item as the reason code, unless {\tt SP} does not
point to a valid cell, in which case reason code $-258$ is returned (see section~\ref{exceptions}).
After a call to {\bf single\_step()} which terminates without
an exception being raised, reason code 0 is returned.

Reason codes which are also valid exception codes (either reserved (see section~\ref{exceptions})
or user exception codes) should not normally be used. This
allows exception codes to be passed back by an exception handler to the calling
program, so that the calling program can handle certain exceptions without
confusing exception codes and reason codes.


\subsection{Exceptions}
\label{exceptions}

When a {\tt THROW} instruction (see section~\ref{exceptinst}) is executed, an
{\bf exception} is said to have been {\bf raised}. Some exceptions are raised by
other instructions, for example by {\tt /} when division by zero is attempted;
these also execute a {\tt THROW}. The exception code is the number on top of the
stack at the time the exception is raised.

Exception codes are signed numbers. $-1$ to $-255$ are reserved for ANS Forth
exception codes, and $-256$ to $-511$ for Beetle's own exception codes; the meanings
of those that may be raised by Beetle are shown in table~\ref{excepttable}. ANS
Forth compilers may raise other exceptions in the range $-1$ to $-255$ and
additionally reserve exceptions $-512$ to $-4095$ for their own exceptions
(see~\cite[section 9.3.1]{ANSIforth}).

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|l|} \hline
\rule[-2mm]{0mm}{6mm}\bf Code & \bf Meaning \\ \hline
$-9$ & Invalid address (see below). \\
$-10$ & Division by zero attempted (see section~\ref{arithmetic}). \\
$-23$ & Address alignment exception (see below). \\
$-256$ & Illegal opcode (see section~\ref{opcodes}). \\
$-257$ & Library routine not implemented (see section~\ref{accessinst}). \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{excepttable}Exceptions raised by Beetle}
\end{table}

Exception -9 is raised whenever an attempt is made to access an invalid address
(not between zero and {\tt MEMORY $-$ 1} inclusive), either by an instruction,
or during an instruction fetch (because {\tt EP} contains an invalid address).
Exception -23 is raised when a bForth instruction expecting an address of type
\spic{a-addr} (cell-aligned) is given a non-aligned address. When Beetle raises
an address exception (-9 or -23), the offending address is placed in {\tt
-ADDRESS}.

The initial values of {\tt 'BAD} and {\tt -ADDRESS} are unlikely to be generated
by an exception, so it may be assumed that if the initial values still hold no
exception has yet occurred.

Address and alignment exceptions are only raised if {\tt CHECKED} is 1. When
{\tt CHECKED} is 0, a faster implementation of Beetle may be used---this is
especially useful for stand-alone Beetles.

If {\tt SP} is unaligned when an exception is raised, or putting the code on the
stack would cause {\tt SP} to be out of range, the effect of a {\tt HALT} with
code $-258$ is performed (although the actual mechanics are not, as that too would
involve putting a number on the stack). Similarly, if {\tt 'THROW} contains an
invalid address, the effect of {\tt HALT} with code $-259$ is performed.


\section{Instruction set}
\label{instset}

The bForth instruction set is listed in sections~\ref{stackinst} to~\ref{recurseinst},
with the instructions grouped according to function. The
instructions are given in the following format:

\begin{description}
\instpr{NAME}{pronunciation}{00h}{before -- after}{before -- after}{Description.}
\end{description}

The first line consists of the name of the instruction followed by the
pronunciation in quotes, and the instruction's opcode. On the right are the
stack comment or comments. Underneath is the description. The two stack comments
show the effect of the instruction on the data and return (R) stacks.

{\bf Stack comments} are written

\centerline{\tt ( \spic{before -- after} )}

where \spic{before} and \spic{after} are stack pictures showing the items on top
of a stack before and after the instruction is executed (the change is called
the {\bf stack effect}). An instruction only affects the items shown in its
stack comments. The brackets and dashes serve merely to delimit the stack
comment and to separate \spic{before} from \spic{after}. {\bf Stack pictures}
are a representation of the top-most items on the stack, and are written

\centerline{\spic{i$_1$ i$_2$\dots i$_{n-1}$ i$_n$}}

where the \spic{i$_k$} are stack items, each of which occupies a whole number of
cells, with \spic{i$_n$} being on top of the stack. The symbols denoting
different types of stack item are shown in table~\ref{typetable}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|l|} \hline
\rule[-2mm]{0mm}{6mm}\bf Symbol & \bf Data type \\ \hline
\spic{flag} & flag \\
\spic{true} & true flag \\
\spic{false} & false flag \\
\spic{char} & character \\
\spic{n} & signed number \\
\spic{u} & unsigned number \\
\spic{n{\tt |}u} & number (signed or unsigned) \\
\spic{x} & unspecified cell \\
\spic{xt} & execution token \\
\spic{a-addr} & cell-aligned address \\
\spic{c-addr} & character-aligned address \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{typetable}Types used in stack comments}
\end{table}

Types are only used to indicate how instructions treat their arguments and
results; Beetle does not distinguish between stack items of different types. In
stack pictures the most general argument types with which each instruction can
be supplied are given; subtypes may be substituted. Using the phrase ``$i
\Rightarrow j$'' to denote ``$i$\/ is a subtype of $j$\/'', table~\ref{reltable}
shows the subtype relationships. The subtype relation is transitive.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|} \hline
\spic{u} $\Rightarrow$ \spic{x} \\
\spic{n} $\Rightarrow$ \spic{x} \\
\spic{char} $\Rightarrow$ \spic{u} \\
\spic{a-addr} $\Rightarrow$ \spic{c-addr} $\Rightarrow$ \spic{u} \\
\spic{flag} $\Rightarrow$ \spic{x} \\
\spic{xt} $\Rightarrow$ \spic{x} \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{reltable}The subtype relation}
\end{table}

Numbers are represented in twos complement form. \spic{a-addr} consists of all
unsigned numbers less than {\tt MEMORY}. Numeric constants can be included in
stack pictures, and are of type \spic{n{\tt |}u}.

Each type may be suffixed by a number in stack pictures; if the same combination
of type and suffix appears more than once in a stack comment, it refers to
identical stack items. Alternative \spic{after} pictures are separated by ``{\tt
|}'', and the circumstances under which each occurs are detailed in the
instruction description.

The symbols \spic{i*x}, \spic{j*x} and \spic{k*x} are used to denote different
collections of zero or more cells of any data type. Ellipsis is used for
indeterminate numbers of specified types of cell.

If an instruction does not modify the return stack, the corresponding stack
picture is omitted. Some instructions have two forms, the latter ending in
``{\tt I}''. This denotes {\tt I}mmediate addressing: the instruction's argument
is included in the instruction cell (see section~\ref{conventions}), rather than
being placed separately in the next available cell.


\subsection{Programming conventions}
\label{conventions}

Since branch destinations must be cell-aligned, some instruction sequences may
contain gaps. These must be padded with {\tt NEXT} (opcode 00h).

Literals and branch addresses should be placed in memory as follows. If a
literal (see section~\ref{literals}) or branch address (see section~\ref{control})
will fit in the rest of the cell directly after its instruction
(see below), it should be placed there, and the immediate form of the
instruction used. Otherwise it should be placed in the cell after the
instruction. Further instructions may still be stored in the current cell. If
more than one literal or branch instruction is encoded in one instruction cell,
the literal values follow each other in successive cells.

Given an instruction cell with \textit{n} bytes free, a literal will fit into
it if it can be represented as an \textit{n}-byte twos complement number.
Immediate mode branch destinations are given as the relative cell count from
the value {\tt EP} will have when the instruction is executed (rather than the
address of the instruction cell containing the instruction) to the address of
the destination instruction cell (not as absolute addresses). The literal or
branch is stored with the bytes in the same order as for a four-byte number, at
the most significant end of the instruction cell.


\subsection{Stack manipulation}
\label{stackinst}

These instructions manage the data stack and move values between stacks.

\begin{description}
\instp{DUP}{dupe}{01h}{x -- x x}{Duplicate \spic{x}.}
\inst{DROP}{02h}{x --}{Remove \spic{x} from the stack.}
\inst{SWAP}{03h}{\x1 \x2 -- \x2 \x1}{Exchange the top two stack items.}
\inst{OVER}{04h}{\x1 \x2 -- \x1 \x2 \x1}{Place a copy of \x1 on top of the stack.}
\instp{ROT}{rote}{05h}{\x1 \x2 \x3 -- \x2 \x3 \x1}{Rotate the top three stack entries.}
\instp{-ROT}{not-rote}{06h}{\x1 \x2 \x3 -- \x3 \x1 \x2}{Perform the action of {\tt ROT} twice.}
\inst{TUCK}{07h}{\x1 \x2 -- \x2 \x1 \x2}{Perform the action of {\tt SWAP} followed by {\tt OVER}.}
\inst{NIP}{08h}{\x1 \x2 -- \x2}{Perform the action of {\tt SWAP} followed by {\tt DROP}.}
\inst{PICK}{09h}{\x{u}\dots\x1 \x0 u -- \x{u}\dots \x1 \x0 \x{u}}{Remove \spic{u}. Copy \x{u} to the top of the stack. If \spic{u}~$=$~0, {\tt PICK} is equivalent to {\tt DUP}. If there are fewer than \spic{u}~$+$~2 items on the stack before {\tt PICK} is executed, the memory cell which would have been \x{u} were there \spic{u}~$+$~2 items is copied to the top of the stack.}
\inst{ROLL}{0Ah}{\x{u} \x{u-1}\dots\x{0} u -- \x{u-1}\dots\x0 \x{u}}{Remove \spic{u}. Rotate \spic{u}~$+$~1 items on the top of the stack. If \spic{u}~$=$~0 {\tt ROLL} does nothing, and if \spic{u}~$=$~1 {\tt ROLL} is equivalent to {\tt SWAP}. If there are fewer than \spic{u}~$+$~2 items on the stack before {\tt ROLL} is executed, the memory cells which would have been on the stack were there \spic{u}~$+$~2 items are rotated.}
\instp{?DUP}{question-dupe}{0Bh}{x -- $0$ {\tt |} x x}{Duplicate \spic{x} if it is non-zero.}
\instpr{>R}{to-r}{0Ch}{x --}{-- x}{Move \spic{x} to the return stack.}
\instpr{R>}{r-from}{0Dh}{-- x}{x --}{Move \spic{x} from the return stack to the data stack.}
\instpr{R@}{r-fetch}{0Eh}{-- x}{x -- x}{Copy \spic{x} from the return stack to the data stack.}
\end{description}

\subsection{Comparison}

These words compare two numbers (or, for equality tests, any two cells) on the
stack, returning a flag, true with all bits set if the test succeeds and false
otherwise.

\begin{description}
\instp{<}{less-than}{0Fh}{\n1 \n2 -- flag}{\spic{flag} is true if and only if \n1 is less than \n2.}
\instp{>}{greater-than}{10h}{\n1 \n2 -- flag}{\spic{flag} is true if and only if \n1 is greater than \n2.}
\instp{=}{equals}{11h}{\x1 \x2 -- flag}{\spic{flag} is true if and only if \x1 is bit-for-bit the same as \x2.}
\instp{<>}{not-equals}{12h}{\x1 \x2 -- flag}{\spic{flag} is true if and only if \x1 is not bit-for-bit the same as \x2.}
\instp{0<}{zero-less}{13h}{n -- flag}{\spic{flag} is true if and only if n is less than zero.}
\instp{0>}{zero-greater}{14h}{n -- flag}{\spic{flag} is true if and only if \spic{n} is greater than zero.}
\instp{0=}{zero-equals}{15h}{x -- flag}{\spic{flag} is true if and only if \spic{x} is equal to zero.}
\instp{0<>}{zero-not-equals}{16h}{x -- flag}{\spic{flag} is true if and only if \spic{x} is not equal to zero.}
\instp{U<}{u-less-than}{17h}{\U1 \U2 -- flag}{\spic{flag} is true if and only if \U1 is less than \U2.}
\instp{U>}{u-greater-than}{18h}{\U1 \U2 -- flag}{\spic{flag} is true if and only if \U1 is greater than \U2.}
\end{description}


\subsection{Arithmetic}
\label{arithmetic}

These instructions consist of monadic and dyadic operators, and numeric
constants. All calculations are made without bounds or overflow checking, except
as detailed for certain instructions.

Constants:

\nopagebreak

\begin{description}
\instp{0}{zero}{19h}{-- $0$}{Leave zero on the stack.}
\instp{1}{one}{1Ah}{-- $1$}{Leave one on the stack.}
\instp{-1}{minus-one}{1Bh}{-- $-1$}{Leave minus one on the stack.}
\inst{CELL}{1Ch}{-- $4$}{Leave four on the stack.}
\instp{-CELL}{minus-cell}{1Dh}{-- $-4$}{Leave minus four on the stack.}
\end{description}

Addition and subtraction:

\nopagebreak

\begin{description}
\instp{+}{plus}{1Eh}{\noru1 \noru2 -- \noru3}{Add \noru2 to \noru1, giving the sum \noru3.}
\instp{-}{minus}{1Fh}{\noru1 \noru2 -- \noru3}{Subtract \noru2 from \noru1, giving the difference \noru3.}
\instp{>-<}{reverse-minus}{20h}{\noru1 \noru2 -- \n3{\tt |}\U3}{Perform the action of {\tt SWAP} (see section~\ref{stackinst}) followed by {\tt -}.}
\instp{1+}{one-plus}{21h}{\noru1 -- \noru2}{Add one to \n1{\tt |}\U1, giving the sum \noru2.}
\instp{1-}{one-minus}{22h}{\noru1 -- \noru2}{Subtract one from \noru1, giving the difference \noru2.}
\instp{CELL+}{cell-plus}{23h}{\noru1 -- \noru2}{Add four to \n1{\tt |}\U1, giving the sum \noru2.}
\instp{CELL-}{cell-minus}{24h}{\noru1 -- \noru2}{Subtract four from \noru1, giving the difference \noru2.}
\end{description}

Multiplication and division (note that all division instructions raise exception
$-10$ if division by zero is attempted, and round the quotient towards minus
infinity, except for {\tt S/REM}, which rounds the quotient towards zero):

\nopagebreak

\begin{description}
\instp{*}{star}{25h}{\noru1 \noru2 -- \noru3}{Multiply \noru1 by \noru2 giving the product \noru3.}
\instp{/}{slash}{26h}{\n1 \n2 -- \n3}{Divide \n1 by \n2, giving the single-cell quotient \n3.}
\inst{MOD}{27h}{\n1 \n2 -- \n3}{Divide \n1 by \n2, giving the single-cell remainder \n3.}
\instp{/MOD}{slash-mod}{28h}{\n1 \n2 -- \n3 \n4}{Divide \n1 by \n2, giving the single-cell remainder \n3 and the single-cell quotient \n4.}
\instp{U/MOD}{u-slash-mod}{29h}{\U1 \U2 -- \U3 \U4}{Divide \U1 by \U2, giving the single-cell remainder \U3 and the single-cell quotient \U4.}
\instp{S/REM}{s-slash-rem}{2Ah}{\n1 \n2 -- \n3 \n4}{Divide \n1 by \n2 using symmetric division, giving the single-cell remainder \n3 and the single-cell quotient \n4.}
\instp{2/}{two-slash}{2Bh}{\x1 -- \x2}{\x2 is the result of shifting \x1 one bit toward the least-significant bit, leaving the most-significant bit unchanged.}
\inst{CELLS}{2Ch}{\n1 -- \n2}{\n2 is the size in bytes of \n1 cells.}
\end{description}

Sign functions:

\nopagebreak

\begin{description}
\instp{ABS}{abs}{2Dh}{n -- u}{\spic{u} is the absolute value of \spic{n}.}
\inst{NEGATE}{2Eh}{\n1 -- \n2}{Negate \n1, giving its arithmetic inverse \n2.}
\end{description}

Maxima and minima:

\nopagebreak

\begin{description}
\inst{MAX}{2Fh}{\n1 \n2 -- \n3}{\n3 is the greater of \n1 and \n2.}
\inst{MIN}{30h}{\n1 \n2 -- \n3}{\n3 is the lesser of \n1 and \n2.}
\end{description}


\subsection{Logic and shifts}

These instructions consist of bitwise logical operators and bitwise shifts. The
result of performing the specified operation on the argument or arguments is
left on the stack.

Logic functions:

\nopagebreak

\begin{description}
\inst{INVERT}{31h}{\x1 -- \x2}{Invert all bits of \x1, giving its logical inverse \x2.}
\inst{AND}{32h}{\x1 \x2 -- \x3}{\x3 is the bit-by-bit logical ``and'' of \x1 with \x2.}
\inst{OR}{33h}{\x1 \x2 -- \x3}{\x3 is the bit-by-bit inclusive-or of \x1 with \x2.}
\instp{XOR}{x-or}{34h}{\x1 \x2 -- \x3}{\x3 is the bit-by-bit exclusive-or of \x1 with \x2.}
\end{description}

Shifts:

\nopagebreak

\begin{description}
\instp{LSHIFT}{l-shift}{35h}{\x1 u -- \x2}{Perform a logical left shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the least significant bits vacated by the shift. If \spic{u} is greater than or equal to 32, \x2 is zero.}
\instp{RSHIFT}{r-shift}{36h}{\x1 u -- \x2}{Perform a logical right shift of \spic{u} bit-places on \x1, giving \x2. Put zero into the most significant bits vacated by the shift. If \spic{u} is greater than or equal to 32, \x2 is zero.}
\instp{1LSHIFT}{one-l-shift}{37h}{\x1 -- \x2}{Perform a logical left shift of one bit-place on \x1, giving \x2. Put zero into the least significant bit vacated by the shift.}
\instp{1RSHIFT}{one-r-shift}{38h}{\x1 -- \x2}{Perform a logical right shift of one bit-place on \x1, giving \x2. Put zero into the most significant bit vacated by the shift.}
\end{description}


\subsection{Memory}
\label{memoryinst}

These instructions fetch and store cells and bytes to and from memory; there is
also an instruction to add a number to another stored in memory.

\begin{description}
\instp{@}{fetch}{39h}{a-addr -- x}{\spic{x} is the value stored at \spic{a-addr}.}
\instp{!}{store}{3Ah}{x a-addr --}{Store \spic{x} at \spic{a-addr}.}
\instp{C@}{c-fetch}{3Bh}{c-addr -- char}{If {\tt ENDISM} is 1, exclusive-or \spic{c-addr} with 3. Fetch the character stored at \spic{c-addr}. The unused high-order bits are all zeroes.}
\instp{C!}{c-store}{3Ch}{char c-addr --}{If {\tt ENDISM} is 1, exclusive-or \spic{c-addr} with 3. Store \spic{char} at \spic{c-addr}. Only one byte is transferred.}
\instp{+!}{plus-store}{3Dh}{n{\tt |}u a-addr --}{Add \spic{n{\tt |}u} to the single-cell number at \spic{a-addr}.}
\end{description}


\subsection{Registers}
\label{registerinst}

As mentioned in section~\ref{registers}, the stack pointers {\tt SP} and {\tt
RP} may only be accessed through special instructions:

\begin{description}
\instp{SP@}{s-p-fetch}{3Eh}{-- a-addr}{\spic{a-addr} is the value of {\tt SP}.}
\instp{SP!}{s-p-store}{3Fh}{a-addr --}{Set {\tt SP} to \spic{a-addr}.}
\instp{RP@}{r-p-fetch}{40h}{-- a-addr}{\spic{a-addr} is the value of {\tt RP}.}
\instp{RP!}{r-p-store}{41h}{a-addr --}{Set {\tt RP} to \spic{a-addr}.}
\end{description}


\subsection{Control structures}
\label{control}

These instructions implement unconditional and conditional branches, subroutine
call and return, and various aspects of the Forth {\tt DO}\dots{\tt LOOP}
construct.

Branches:

\nopagebreak

\begin{description}
\inst{BRANCH}{42h}{--}{Load {\tt EP} from the cell it points to, then perform the action of {\tt NEXT}.}
\instp{BRANCHI}{branch-i}{43h}{--}{Add {\tt A} $\times$ 4 to {\tt EP}, then perform the action of {\tt NEXT}.}
\instp{?BRANCH}{question-branch}{44h}{flag --}{If \spic{flag} is false then load {\tt EP} from the cell it points to and perform the action of {\tt NEXT}; otherwise add four to {\tt EP}.}
\instp{?BRANCHI}{question-branch-i}{45h}{flag --}{If \spic{flag} is false then add {\tt A} $\times$ 4 to {\tt EP}. Perform the action of {\tt NEXT}.}
\instr{EXECUTE}{46h}{xt --}{ -- a-addr}{Push {\tt EP} on to the return stack, put \spic{xt} into {\tt EP}, then perform the action of {\tt NEXT}.}
\instpr{@EXECUTE}{fetch-execute}{47h}{\aaddr1 --}{ -- \aaddr2}{Push {\tt EP} on to the return stack, put the contents of \spic{a-addr} into {\tt EP}, then perform the action of {\tt NEXT}.}
\end{description}

Subroutine call and return:

\nopagebreak

\begin{description}
\instr{CALL}{48h}{--}{-- a-addr}{Push {\tt EP} $+$ 4 on to the return stack, then load {\tt EP} from the cell it points to. Perform the action of {\tt NEXT}.}
\instpr{CALLI}{call-i}{49h}{--}{-- a-addr}{Push {\tt EP} on to the return stack, then add A $\times$ 4 to {\tt EP}. Perform the action of {\tt NEXT}.}
\instr{EXIT}{4Ah}{--}{a-addr --}{Put \spic{a-addr} into {\tt EP}, then perform the action of {\tt NEXT}.}
\end{description}

{\tt DO}\dots{\tt LOOP} support:

\nopagebreak

\begin{description}
\instpr{(DO)}{bracket-do}{4Bh}{\x1 \x2 --}{-- \x1 \x2}{Move the top two items on the data stack to the return stack.}
\instpr{(LOOP)}{bracket-loop}{4Ch}{--}{\noru1 \noru2 -- {\tt |} \noru1 \noru3}{Add one to \noru2; if it then equals \noru1 discard both items and add four to {\tt EP}, otherwise load {\tt EP} from the cell to which it points and perform the action of {\tt NEXT}.}
\instpr{(LOOP)I}{bracket-loop-i}{4Dh}{--}{\noru1 \noru2 -- {\tt |} \noru1 \noru3}{Add one to \noru2; if it then equals \noru1 discard both items, otherwise add {\tt A} $\times$ 4 to {\tt EP}. Perform the action of {\tt NEXT}.}
\instpr{(+LOOP)}{bracket-plus-loop}{4Eh}{\noru1 --}{\noru2 \noru3 -- {\tt |} \noru2 \noru4}{Add \noru1 to \noru3; if \noru3 thereby crosses the $($\noru2 $-$ 1$)$ to \noru2 boundary discard both items and add four to {\tt EP}, otherwise load {\tt EP} from the cell to which it points and perform the action of {\tt NEXT}.}
\instpr{(+LOOP)I}{bracket-plus-loop-i}{4Fh}{\noru1 --}{\noru2 \noru3 -- {\tt |} \noru2 \noru4}{Add \noru1 to \noru3; if \noru3 thereby crosses the $($\noru2 $-$ 1$)$ to \noru2 boundary discard both items, otherwise add {\tt A} $\times$ 4 to {\tt EP}. Perform the action of {\tt NEXT}.}
\instr{UNLOOP}{50h}{--}{\x1 \x2 --}{Discard the top two items on the return stack.}
\instr{J}{51h}{-- \x1}{\x1 \x2 \x3 -- \x1 \x2 \x3}{Copy the third item on the return stack to the data stack.}
\end{description}


\subsection{Literals}
\label{literals}

These instructions encode literal values which are placed on the stack.

\begin{description}
\instp{(LITERAL)}{bracket-literal}{52h}{-- x}{Push the cell pointed to by {\tt EP} on to the stack, then add four to {\tt EP}.}
\instp{(LITERAL)I}{bracket-literal-i}{53h}{-- x}{Push the contents of {\tt A} on to the stack. Perform the action of {\tt NEXT}.}
\end{description}


\subsection{Exceptions}
\label{exceptinst}

These instructions give access to Beetle's exception mechanisms.

\begin{description}
\instp{THROW}{throw}{54h}{--}{Put the contents of {\tt EP} into {\tt 'BAD}, then load {\tt EP} from {\tt 'THROW}. Perform the action of {\tt NEXT}. If {\tt 'THROW} contains an out of range or unaligned address stop Beetle, returning reason code -259 to the calling program (see section~\ref{calls}).}
\inst{HALT}{55h}{x --}{Stop Beetle, returning reason code \spic{x} to the calling program (see section~\ref{calls}). If {\tt SP} is out of range or unaligned, $-258$ is returned as the reason code.}
\end{description}


\subsection{Miscellaneous}
\label{miscinst}

{\tt (CREATE)} implements part of the Forth {\tt CREATE}\dots{\tt DOES>}
construct. {\tt NEXT} performs an instruction fetch when Beetle runs out of
instructions in the {\tt A} register.

\begin{description}
\instp{(CREATE)}{bracket-create}{56h}{-- a-addr}{Push {\tt EP} on to the stack.}
\inst{NEXT}{00h/FFh}{--}{Load the cell pointed to by {\tt EP} into {\tt A} then add four to {\tt EP}.}
\end{description}


\subsection{External access}
\label{accessinst}

These instructions allow access to Beetle's libraries, the operating system and
native machine code.

\begin{description}
\inst{LIB}{57h}{i*x n -- j*x}{Call library routine \spic{n}. The parameters passed and returned depend on \spic{n}. If the library routine is not currently available, raise exception -257.}
\instp{OS}{o-s}{58h}{i*x -- j*x}{Make an operating system call. {\tt OS} typically takes an operating system call number then makes that call and returns any result, with other parameters and result data being communicated via the stack or a shared data area.}
\inst{LINK}{59h}{i*x --}{Make a subroutine call to the routine at the address given (in the host machine's format, padded out to a number of cells) on the data stack. The size and format of this address are machine-dependent.}
\end{description}


\subsection{Recursion}
\label{recurseinst}

These instructions are provided to simplify the task of writing a low-level
debugger for Beetle that runs directly on Beetle. Such a debugger might be
written in pForth. The instructions perform roughly the same function as the
interface calls {\bf run()} and {\bf single\_step()}.

\begin{description}
\inst{RUN}{5Ah}{\aaddr1 \aaddr2 \aaddr3 x -- n}{Save the current values of {\tt EP}, {\tt A}, {\tt SP}, {\tt RP}, {\tt 'THROW}, {\tt 'BAD} and {\tt -ADDRESS} and load \aaddr1 into {\tt SP}, \aaddr2 into {\tt RP}, \aaddr3 into {\tt EP}, and \spic{x} into {\tt A}. Enter the execution loop. If Beetle halts, restore the contents of the registers to those saved, and push the reason code on to the stack.}
\inst{STEP}{5Bh}{\aaddr1 \aaddr2 \aaddr3 x -- n}{Save the current values of {\tt EP}, {\tt A}, {\tt SP}, {\tt RP}, {\tt 'THROW}, {\tt 'BAD} and {\tt -ADDRESS} and load \aaddr1 into {\tt SP}, \aaddr2 into {\tt RP}, \aaddr3 into {\tt EP} and \spic{x} into {\tt A}. Perform the contents of the execution loop once. Restore the contents of the registers to those saved, and push the reason code on to the stack.}
\end{description}


\subsection{Opcodes}
\label{opcodes}

In table~\ref{opcodetable} are listed the opcodes in numerical order. All
undefined opcodes (5Ch--FEh) raise exception -256.

\begin{table}[htb]
\begin{center}
\begin{tabular}{*{3}{|cc}|} \hline
\rule[-2mm]{0mm}{6mm}\bf Opcode & \bf Instruction & \bf Opcode & \bf
    Instruction & \bf Opcode & \bf Instruction \\ \hline
\opcodetbl{00}{NEXT}	{1F}{-}		{3E}{SP@}
\opcodetbl{01}{DUP}	{20}{>-<}	{3F}{SP!}
\opcodetbl{02}{DROP}	{21}{1+}	{40}{RP@}
\opcodetbl{03}{SWAP}	{22}{1-}	{41}{RP!}
\opcodetbl{04}{OVER}	{23}{CELL+}	{42}{BRANCH}
\opcodetbl{05}{ROT}	{24}{CELL-}	{43}{BRANCHI}
\opcodetbl{06}{-ROT}	{25}{*}		{44}{?BRANCH}
\opcodetbl{07}{TUCK}	{26}{/}	{45}{?BRANCHI}
\opcodetbl{08}{NIP}	{27}{MOD}	{46}{EXECUTE}
\opcodetbl{09}{PICK}	{28}{/MOD}	{47}{@EXECUTE}
\opcodetbl{0A}{ROLL}	{29}{U/MOD}	{48}{CALL}
\opcodetbl{0B}{?DUP}	{2A}{S/REM}	{49}{CALLI}
\opcodetbl{0C}{>R}	{2B}{2/}	{4A}{EXIT}
\opcodetbl{0D}{R>}	{2C}{CELLS}	{4B}{(DO)}
\opcodetbl{0E}{R@}	{2D}{ABS}	{4C}{(LOOP)}
\opcodetbl{0F}{<}	{2E}{NEGATE}	{4D}{(LOOP)I}
\opcodetbl{10}{>}	{2F}{MAX}	{4E}{(+LOOP)}
\opcodetbl{11}{=}	{30}{MIN}	{4F}{(+LOOP)I}
\opcodetbl{12}{<>}	{31}{INVERT}	{50}{UNLOOP}
\opcodetbl{13}{0<}	{32}{AND}	{51}{J}
\opcodetbl{14}{0>}	{33}{OR}	{52}{(LITERAL)}
\opcodetbl{15}{0=}	{34}{XOR}	{53}{(LITERAL)I}
\opcodetbl{16}{0<>}	{35}{LSHIFT}	{54}{THROW}
\opcodetbl{17}{U<}	{36}{RSHIFT}	{55}{HALT}
\opcodetbl{18}{U>}	{37}{1LSHIFT}	{56}{(CREATE)}
\opcodetbl{19}{0}	{38}{1RSHIFT}	{57}{LIB}
\opcodetbl{1A}{1}	{39}{@}		{58}{OS}
\opcodetbl{1B}{-1}	{3A}{!}		{59}{LINK}
\opcodetbl{1C}{CELL}	{3B}{C@}	{5A}{RUN}
\opcodetbl{1D}{-CELL}	{3C}{C!}	{5B}{STEP}
\opcodetbl{1E}{+}	{3D}{+!}	{FF}{NEXT}	\hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{opcodetable}Beetle's opcodes}
\end{table}


\section{External interface}

Beetle's external interface comes in three parts. The calling interface allows
Beetle to be controlled by other programs. The library format provides a simple
mechanism for Beetle to access I/O and other system-dependent functions via the
{\tt LIB} instruction. User-written libraries may also be used, allowing Beetle
to benefit from previously written code, code written in other languages, and
the speed of machine code in time-critical situations. The object module format
allows compiled code to be saved, reloaded and shared between systems. pForth is
loaded from an object module.


\subsection{Object module format}
\label{object}

The first six bytes of an object module should be the ASCII codes of the letters
``BEETLE''; next should come an ASCII NUL (00h), then the one-byte contents of
the {\tt ENDISM} register of the Beetle which saved the module. The next four
bytes should contain the number of cells the code occupies. The number must have
the same endianness as that indicated in the previous byte. Then follows the
code, which must fill a whole number of cells. The format is summarised in table~\ref{objecttable}
(the bytes in each cell are shown in the order in which they
are stored in the file, regardless of the endianness of the machine on which the
file is written).

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|l|} \hline
\rule[-2mm]{0mm}{6mm}\bf Cell & \bf Contents \\ \hline
1 & 42h 45h 45h 54h \\ \hline
2 & 4Ch 45h 00h {\tt ENDISM} \\ \hline
3 & Length $l$\/ \\ \hline
4 & 1st cell of code\dots \\ \hline
$\vdots$ & \multicolumn{1}{c|}{$\vdots$} \\ \hline
$l+3$\/ & \dots$l$\/th cell of code \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{objecttable}Object module format}
\end{table}

Object modules have a simple structure, as they are only intended for loading an
initial memory image into Beetle, such as the pForth compiler. Forth does not
typically support the loading of compiled code into the compiler, nor there is
any need, as compilers are fast, and an incremental style of program
development, with only a little source code being recompiled at a time, is
typically used.


\subsection{Library format}

The first six bytes of a library file should be the ASCII codes of the letters
``BEETLE''; next should come FFh followed by the one-byte contents of the {\tt
ENDISM} register of the Beetle which saved the library. Next is a cell
containing the number of library routines in this library. After this come the
routines: first a cell containing the number of the routine (the same as that
passed to {\tt LIB} to call that routine), then a cell with the length of the
routine in bytes, then the machine code itself, padded if necessary with 00h to
a whole number of cells. The number of routines, routine numbers and lengths
should be stored with the same endianness as that indicated earlier. The format
is summarised in table~\ref{libtable} (the bytes in each cell are shown in the
order in which they are stored in the file, regardless of the endianness of the
machine on which the file is written).

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|l|} \hline
\rule[-2mm]{0mm}{6mm}\bf Cell & \bf Contents \\ \hline
1 & 42h 45h 45h 54h \\ \hline
2 & 4Ch 45h FFh {\tt ENDISM} \\ \hline
3 & Number of calls \\ \hline
4 & 1st call number \\ \hline
5 & 1st call length $l$\/ \\ \hline
6 & 1st cell of code\dots \\ \hline
$\vdots$ & \multicolumn{1}{c|}{$\vdots$} \\ \hline
$l+5$\/ & \dots$l$\/th cell of code \\ \hline
$\vdots$ & \multicolumn{1}{c|}{$\vdots$} \\ \hline
$\vdots$ & further calls \\ \hline
$\vdots$ & \multicolumn{1}{c|}{$\vdots$} \\ \hline
\end{tabular}
\end{center}
\vspace{-2mm}
\caption{\label{libtable}Library format}
\end{table}

If relocation tables or other data are needed for the machine code to work, they
should be included with the code; it is up to the implementation how to decode
the machine code sections of the library file.


\subsection{Calling interface}
\label{calls}

The calling interface is difficult to specify with the same precision as the
rest of Beetle, as it may be implemented in any language. However, since only
basic types are used, and the semantics are simple, it is expected that
implementations in different language producing the same result will be easy to
program. A Modula-like syntax is used to give the definitions here.
Implementation-defined error codes must be documented, but are optional. All
addresses passed as parameters must be cell-aligned. There are six calls which a
Beetle must provide:

\begin{description}
\iface{run}{}{integer}{Start Beetle by entering the execution cycle as
    described in section~\ref{operation}. If Beetle ever executes a {\tt
    HALT} instruction (see section~\ref{exceptinst}), the reason code is
    returned as the result.}
\iface{single\_step}{}{integer}{Execute a single pass of the execution
    cycle, and return reason code $-260$, unless a {\tt HALT} instruction was
    obeyed (see section~\ref{exceptinst}), in which case the reason code
    passed to it is returned.}
\iface{load\_object}{file, address}{integer}{Load the object module
    specified by \textit{file}, which may be a filename or some other
    specifier, to the Beetle address \textit{address}. First the module's
    header is checked; if the first seven bytes are not as specified above
    in section~\ref{object}, or the endianness value is not 0 or 1, then
    return -2. If the code will not fit into memory at the address given, or the
    address is out of range, return $-1$. Otherwise load the bForth code into
    memory, resexing it if the endianness value is different from the current
    value of {\tt ENDISM}. The result is 0 if successful, and some other
    implementation-defined value if there is a filing system or other error.}
\iface{save\_object}{file, address, length}{integer}{Save the \textit{length}
    cells in Beetle's memory starting at \textit{address} as an object module
    under the filename or other specifier \textit{file}. The result is 0 if
    successful, $-1$ if there is a Beetle error (the address is out of range or
    the area extends beyond {\tt MEMORY}), and some other
    implementation-defined value if there is a filing system or other error.}
\iface{load\_library}{file}{integer}{Load the library specified by
    \textit{file}, which may be a filename or some other specifier. Return 0 if
    successful, or some other implementation-defined value if not. It is up
    to the implementation whether particular library calls may be loaded
    more than once; if this is allowed, the old version should be
    overwritten by the new.}
\iface{save\_standalone}{file, size, start, copied, libs}{integer}{Write an
    executable stand-alone Beetle to the file \textit{file}, which may be a
    filename or some other specifier. The executable should have {\tt
    MEMORY} equal to \textit{size}, and the first \textit{copied} cells should
    have the contents of the \textit{copied} cells in the current Beetle
    starting at \textit{start}. The library calls specified in the list of
    cells \textit{libs} should be linked to the executable, and the current
    values of the registers should be stored. The result is 0 if successful,
    $-1$ if the area extends beyond {\tt MEMORY}, or some other
    implementation-defined value if there is a filing system or other error. See
    section~\ref{standalone} for the behaviour required of the stand-alone
    Beetle.}
\end{description}

Beetle must also provide access to its registers and address space through
appropriate data objects.


\subsection{Stand-alone Beetles}
\label{standalone}

A stand-alone Beetle should perform the following steps when it is executed:

\begin{enumerate}
\item Initialise the registers with the values they held when the
    stand-alone Beetle was saved.
\item Perform the action of {\tt NEXT}.
\item Perform the action of a call to {\bf run()}.
\end{enumerate}

If the Beetle stops with a reason code, this should be returned to the calling
environment if this is supported; otherwise it may be ignored. The stand-alone
program should then terminate.

Any library calls which were linked to the stand-alone Beetle must execute
correctly when called by the {\tt LIB} instruction. Any other parameter passed
to {\tt LIB} should raise exception $-257$ (library call not implemented).


\section{Libraries}
\label{libraries}

Beetle has one standard library, the core I/O library. Its routines mimic the
four system-dependent I/O words in the ANS Forth Core Word Set. The descriptions
below are identical to those given for bForth instructions (see section~\ref{instset}),
except that the opcode is replaced by the routine number, which
is passed to {\tt LIB} to call the routine.

\begin{description}
\instp{BL}{b-l}{0}{-- char}{\spic{char} is the character value for a space.}
\instp{CR}{c-r}{1}{--}{Cause subsequent output to appear at the beginning of the next line.}
\inst{EMIT}{2}{x --}{If \spic{x} is a graphic character in the implementation-defined character set, display \spic{x}. The effect of {\tt EMIT} for all other values of \spic{x} is implementation-defined. When passed a character whose character-defining bits have a value between 20h and 7Eh inclusive, the corresponding character from the ASCII code~\cite{ASCII} is displayed.}
\inst{KEY}{3}{-- char}{Receive one character \spic{char}, a member of the implementation-defined character set. Keyboard events that do not correspond to such characters are discarded until a valid character is received, and those events are subsequently unavailable. Any standard character returned by {\tt KEY} has the numeric value specified by the ASCII code~\cite{ASCII}.}
\end{description}

For more precise information on the behaviour of the library calls, see the
descriptions of the corresponding words in \cite[chapter 6]{ANSIforth}.


\section*{Acknowledgements}

Leo Brodie's marvellous books \cite{starting4th,thinking4th} turned my abstract
enthusiasm for a mysterious language into actual knowledge and appreciation.

I have taken or extrapolated the pronunciations of Forth words from \cite{ANSIforth}.

Martin Richards's demonstration of his BCPL-oriented Cintcode virtual machine
convinced me that this project was worth attempting. He also gave valuable
advice on Beetle's design and proof-read this paper.

Tony Thomas read an earlier draft of this paper, and gave advice on making it
more understandable to readers without a knowledge of Forth.
