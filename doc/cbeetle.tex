%
% Documentation for C Beetle
%
% Reuben Thomas
%
% 1/12/94-8/5/95, 2/3,6-12/6/96
% body separated out 2/3/96
% updated bibliography citations and list of machine architectures 1/6/06
% fixed one last citation 17/2/11
%


\section{Introduction}

The Beetle virtual processor \cite{beetledis} provides a portable environment
for the pForth Forth compiler \cite{beetledis}, a compiler for ANSI Standard
Forth \cite{ANSIforth}. To move pForth between different machines and
operating systems, only Beetle need be rewritten. However, even this can be
avoided if Beetle is itself written in ANSI C, since almost all machines have
an ANSI C compiler available for them.

Writing Beetle in C necessarily leads to a loss of performance for a system
which is already relatively slow by virtue of using a virtual processor
rather than compiling native code. However, pForth is intended mainly as a
didactic tool, offering a concrete Forth environment which may be used to
explore the language, and particularly the implementation of the compiler, on
a simple architecture designed to support Forth. Thus speed is not crucial,
and on modern systems even a C implementation of Beetle can be expected to
run at an acceptable speed.

C Beetle provides only the virtual processor, not a user interface. A simple
user interface is described in \cite{beetledis}.

The interface to an embedded Beetle is described in \cite{beetledis}. This paper
only describes the features specific to this implementation.


\section{Omissions}
\label{omissions}

Certain features of Beetle cannot be rendered portably in C, and so have been
left out of this implementation. Thus, this implementation does not fully
meet the specification for an embedded Beetle.

The {\tt OS} instruction is not implemented, as it depends on the operating
system of the host machine, and this implementation of Beetle is meant to be
portable. If executed, {\tt OS} does nothing.

The interface call {\bf save\_standalone()} is not implemented, as it is
difficult to implement portably without it merely using C Beetle to run an
object file, which lacks the usual advantages of stand-alone programs, speed
and compactness. For similar reasons, {\bf load\_library()} is not
implemented either; the use of {\tt LINK} to access C functions is
recommended instead.

The recursion instructions {\tt STEP} and {\tt RUN} are not implemented,
although they may be added in a future version.


\section{Using C Beetle}

This section describes how to compile C Beetle, and the exact manner in which
the interface calls and Beetle's memory and registers should be accessed.


\subsection{Configuration}
\label{configuration}

\begin{table}
\begin{center}
\begin{tabular}{|c|c|} \hline
\rule[-2mm]{0mm}{6mm}\bf Machine type & \bf Symbol \\ \hline
RISC OS & {\tt riscos} \\
MS DOS & {\tt MSDOS} \\
Atari TOS & {\tt atarist} \\
System V-style UNIX & {\tt sysv} \\
BSD-style Unix & {\tt bsd} \\
\hline
\end{tabular}
\caption{\label{machtab}Supported machine types}
\end{center}
\end{table}

It is impossible to write an ANSI C implementation of Beetle that will run
unaltered on any machine. The few features that are machine-dependent are
defined in a machine header file, which is included by {\tt bportab.h}. The
appropriate symbol for the machine on which C Beetle is to be compiled must
be defined, and the machine header file will then be included automatically.
The machine header files available at the time of writing are shown in
table~\ref{machtab}, together with the corresponding symbol that should be
defined. These symbols are automatically defined by GNU C on the
corresponding machines; if another compiler is used, the appropriate symbol
should be defined. If C Beetle is to be compiled on a machine type not in the
list, a new header file must be added to the directory {\tt bportab},
modelled on the existing header files there, and {\tt bportab.h} must be
changed to load it.

The machine type {\tt Unix} refers to most Unix machines. Systems tested
successfully include System V Release 4, DEC OSF/1 and DEC ULTRIX. Some
problems were encountered, which had effects ranging from impaired operation
to non-compilation, but most are too machine and installation specific to be
worth describing. The general observation may be made that when compiling on
a 64-bit architecture many error messages may be generated by the
compiler about pointer conversions. These occur because offsets into Beetle's
address space are represented as four-byte numbers. As long as Beetle is
never allocated more than 4Gb for its memory, this will not be a problem.

The following types must be defined in a machine header file:

\begin{description}
\item[{\tt BYTE}:]an unsigned eight-bit quantity (Beetle's byte).
\item[{\tt CELL}:]a signed four-byte quantity (Beetle's cell).
\item[{\tt UCELL}:]an unsigned four-byte quantity (an unsigned cell).
\end{description}

The following symbols should be defined if appropriate:

\begin{description}
\item[{\tt BIG\_ENDIAN}] should be defined in the makefile to define the
symbol of the same name whenever the C compiler is invoked if Beetle is
compiled on a big-endian machine.
\item[{\tt FLOORED}]should be defined if the C compiler performs floored
division.
\end{description}

The following macros should also be defined:

\begin{description}
\item[{\tt ARSHIFT(n, p)}]should be set to a macro that assigns to {\tt n}
the result of shifting it right arithmetically {\tt p} places, where {\tt p}
may range from 0 to 31.
\item[{\tt LINK}]should be set to a macro that, calls the C function at the
machine address held on top of Beetle's stack. This address will typically
occupy one cell, but may occupy more. The macro must then alter {\tt SP} so
that the address is popped from the stack.
\item[{\tt GETCH}]should be set to a macro that returns the next key-press
without buffering and echo (like Curses's {\tt getch()}).
\item[{\tt PUTCH(c)}]should be set to a macro that prints the character {\tt
c} to {\tt stdout} without buffering.
\item[{\tt NEWL}]should be set to a macro that prints a \verb$\n$ on {\tt
stdout} without buffering.
\end{description}

The register {\tt CHECKED} must be set (in {\tt beetle.h}) at compile-time:
set to one, address checking will be enabled, and set to zero it will be
disabled. Its value cannot be altered at run-time. {\tt MEMORY} can similarly
be altered from its default value of 16384 if desired.

The C compiler must use twos-complement arithmetic. The settings in {\tt
bportab.h} are tested when the Beetle tests are run. If any is incorrect, the
changes that should be made are listed.


\subsection{Compilation}

The utility Make is required to compile Beetle as supplied; this is available
on most systems. First, edit the makefile, which is called {\tt Makefile}, so
that it will work with the C compiler and linker to be used. The variables
{\tt CCflags}, {\tt Linkflags}, {\tt CC} and {\tt Link} may need to be
changed. Then set {\tt Touch} so that it will, when prepended to a filename,
form a command that changes the timestamp of the file to the current time (on
many systems, {\tt touch} is the correct command).

Now run Make with {\tt Makefile} as the makefile, and C Beetle should
compile. To test the Beetle, run the script file {\tt btests}. The Beetle
object files can be made separately as the target {\tt beetle}; the test
programs can be made as the target {\tt btests}.


\subsection{Registers and memory}

Beetle's registers are declared in {\tt beetle.h}. Their names correspond to
those given in \cite[section~A.2.1]{beetledis}, although some have been changed
to meet the requirements for C identifiers. C Beetle does not allocate any
memory for Beetle, nor does it initialise any of the registers. C Beetle
provides the interface call {\bf init\_beetle()} to do this (see
section~\ref{usingcalls}).

The variables {\tt I}, {\tt A}, {\tt MEMORY}, {\tt BAD} and {\tt ADDRESS}
correspond exactly with the Beetle registers they represent, and may be read
and assigned to accordingly, bearing in mind the restrictions on their use
given in \cite{beetledis} (e.g. copies of {\tt BAD} and {\tt ADDRESS} must be
kept in Beetle's memory). {\tt THROW} is a pointer to the Beetle register
{\tt 'THROW}, so the expression {\tt *THROW} may be used as the Beetle
register. {\tt CHECKED} is a constant expression which may be read but not
assigned to.

{\tt EP}, {\tt M0}, {\tt SP} and {\tt RP} are machine pointers to the
locations in Beetle's address space to which the corresponding Beetle
registers point. Appropriate conversions (pointer addition or subtraction
with {\tt M0}) must therefore be made before using the value of one of these
variables as a Beetle address, and when assigning a Beetle address to one of
the corresponding registers. Examples of such conversions may be found in
{\tt execute.c}, where the bForth instructions are implemented.

The memory is accessed via {\tt M0}, which points to the first byte of
memory. Before Beetle is started by calling {\bf run()} or {\bf
single\_step()}, {\tt M0} must be set to point to a byte array which will be
Beetle's memory.


\subsection{Using the interface calls}
\label{usingcalls}

The operation of the interface calls (except for {\bf init\_beetle()}) is
given in \cite{beetledis}. Here, the C prototypes corresponding to the idealised
prototypes used in \cite{beetledis} are given.

Files to be loaded and saved are passed as C file descriptors. Thus, the
calling program must itself open and close the files.

\begin{description}
\ifacec{CELL run()}{The reason code returned by {\bf run()} is a Beetle
cell.}
\ifacec{CELL single\_step()}{The reason code returned by {\bf single\_step()}
is a Beetle cell.}
\ifacec{int load\_object(FILE *file, CELL *address)}{If a filing error
occurs, the return code is -3, which corresponds to a return value of {\tt
EOF} from {\bf getc()}.}
\ifacec{int save\_object(FILE *file, CELL *address, UCELL length)}{If a
filing error occurs, the return code is -3, which corresponds to a return
value of {\tt EOF} from {\bf putc()}.}
\end{description}

{\bf load\_library()} and {\bf save\_standalone()} are not implemented (see
section~\ref{omissions}).

In addition to the required interface calls C Beetle provides {\bf
init\_beetle()} which, given a byte array, its size and an initial value for
{\tt EP}, initialises Beetle:

\begin{description}
\ifacec{int init\_beetle(BYTE *b\_array, long size, UCELL e0)}{{\tt size} is
the length of {\tt b\_array} in {\em cells} (not bytes), and {\tt e0} is the
Beetle address to which EP will be set. The return value is -1 if {\tt e0} is
not aligned or out of range, and 0 otherwise. All the registers are
initialised as per \cite{beetledis}, and those held in Beetle's memory as well
are copied there. Various tests are made to ensure that Beetle has compiled
properly, and the program will stop and display diagnostic messages if not.}
\end{description}

Programs which use C Beetle's interface must {\tt \#include} the header file
{\tt beetle.h} and be linked with the object files corresponding to the
interface calls used; these are given in table \ref{objtable}. {\tt
opcodes.h}, which contains an enumeration type of Beetle's instruction set,
and {\tt debug.h}, which contains useful debugging functions such as
disassembly, may also be useful; they are not documented here. (To use the
functions in {\tt debug.h}, link with {\tt debug.o}.)

\begin{table}
\begin{center}
\begin{tabular}{|c|c|} \hline
\rule[-2mm]{0mm}{6mm}\bf Interface call & \bf Object file \\ \hline
{\bf run()} & {\tt run.o} \\
{\bf single\_step()} & {\tt step.o} \\
{\bf load\_object()} & {\tt loadobj.o} \\
{\bf save\_object()} & {\tt saveobj.o} \\
{\bf init\_beetle()} & {\tt storage.o} and {\tt tests.o} \\  \hline
\end{tabular}
\caption{\label{objtable}Object files corresponding to interface calls}
\end{center}
\end{table}


\subsection{Other extras provided by C Beetle}

C Beetle provides the following extra quantities and macro in {\tt beetle.h}
which are useful for programming with Beetle:

\begin{description}
\item[{\tt B\_TRUE}:] a cell with all bits set, which Beetle uses as a true
flag.
\item[{\tt B\_FALSE}:] a cell with all bits clear, which Beetle uses as a
false flag.
\item[{\tt CELL\_W}:] the width of a cell in bytes (4).
\item[{\tt NEXT}:] a macro which performs the action of the {\tt NEXT}
instruction.
\end{description}
